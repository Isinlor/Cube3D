<canvas id="canvas1" width="500" height="500"></canvas>
<script>

window.requestAnimFrame = (function(){
  return  window.requestAnimationFrame || 
          window.webkitRequestAnimationFrame || 
          window.mozRequestAnimationFrame || 
          window.oRequestAnimationFrame || 
          window.msRequestAnimationFrame || 
          function(/* function FrameRequestCallback */ callback, /* DOMElement Element */ element){
            window.setTimeout(callback, 1000 / 60);
          };
})();

// function setPixel(imageData, x, y, rgb=[0,0,0], a = 255) {
//     index = (x + y * imageData.width) * 4;
//     imageData.data[index+0] = rgb[0];
//     imageData.data[index+1] = rgb[1];
//     imageData.data[index+2] = rgb[2];
//     imageData.data[index+3] = a;
//     return;
// }

function drawLine(A, B) {
	if (typeof A == "undefined" || typeof B == "undefined") {
		return;
	}
	// if (B.y == A.y && B.x == A.x) {
    //    	setPixel(imageData, B.y, B.x);
	// } else {
	// 	var dx = A.y - B.y; 
	// 	var sx = (dx < 0) ? -1 : 1;
	// 	var dy = A.x - B.x; 
	// 	var sy = (dy < 0) ? -1 : 1;

	// 	if (Math.abs(dy) < Math.abs(dx))
	// 	{    
	// 	    var a = dy / dx;
	// 	    var b = B.x - a * B.y;
	// 	    var i = B.y;
	// 	    while (i != A.y)
	// 	    {
	// 	        setPixel(imageData, Math.round(a*i + b), i);
	// 	        i += sx;
	// 	    }
	// 	} 
	// 	else 
	// 	{
	// 	    var a = dx / dy;
	// 	    var b = B.y - a * B.x;
	// 	    var i = B.x;
	// 	    while (i != A.x)
	// 	    {
	// 	        setPixel(imageData, i, Math.round(a*i + b));
	// 	        i += sy;
	// 	    }    
	// 	}
	// }
	// return;
	c.beginPath();
	c.moveTo(A.x,A.y);
	c.lineTo(B.x,B.y);
	c.stroke();
}

var point = function point (x, y) {
	this.x = x;
	this.y = y;
}

point.prototype = {
	rotate: function (center, theta) {
		var cosTheta = Math.cos(theta);
		var sinTheta = Math.sin(theta);
		this.translate(-center.x, -center.y);
	    var p0 = this.x*cosTheta-this.y*sinTheta;
	    var p1 = this.x*sinTheta+this.y*cosTheta;
		this.x = p0;
		this.y = p1;
		this.round();
		this.translate(center.x, center.y);
	},
	translate: function (x, y) {
		this.x += x;
		this.y += y;
	},
	round: function() {
		this.x = Math.round(this.x);
		this.y = Math.round(this.y);
	},
	draw: function() {
		c.fillRect(this.x, this.y, 1, 1);
	}
}

var point3d = function point3d (x, y, z) {
	this.x = x;
	this.y = y;
	this.z = z;
}

point3d.prototype = {
	rotateAroundAxis: function(axis, center, theta) {
		var coordName1 = '',
			coordName2 = '',
			point2d = new point();
		switch (axis) {
			case axis = 'x':
				coordName1 = 'y';
				coordName2 = 'z';
				break;
			case axis = 'y':
				coordName1 = 'z';
				coordName2 = 'x';
				break;
			case axis = 'z':
				coordName1 = 'x';
				coordName2 = 'y';
				break;

		}
		point2d = this.projectionOn(coordName1, coordName2);
		point2d.rotate(center, theta);
		this[coordName1] = point2d.x;
		this[coordName2] = point2d.y;

	},
	translate: function(x, y, z) {
		this.x += x;
		this.y += y;
		this.z += z;
	},
	round: function() {

	},
	projectionOn: function (axis1, axis2) {
		return new point(this[axis1], this[axis2]);
	}
}


var cube = function cube (A, a, transparent) {
	this.a = a;
	this.vertex = new Array();
	this.vertex2d = new Array();
	this.vertex[0] = A;
	this.vertex[1] = new point3d(A.x+a, A.y, A.z);
	this.vertex[2] = new point3d(A.x, A.y+a, A.z);
	this.vertex[3] = new point3d(A.x, A.y, A.z+a);
	this.vertex[4] = new point3d(A.x+a, A.y+a, A.z);
	this.vertex[5] = new point3d(A.x+a, A.y, A.z+a);
	this.vertex[6] = new point3d(A.x, A.y+a, A.z+a);
	this.vertex[7] = new point3d(A.x+a, A.y+a, A.z+a);

	this.center = new point3d();
	this.center.x = this.vertex[0].x + this.a/2;
	this.center.y = this.vertex[0].y + this.a/2;
	this.center.z = this.vertex[0].z + this.a/2;

	if (typeof transparent == "undefined") {
			this.transparent == false;
		} else {
			this.transparent = transparent;
	}
}

cube.prototype = {
	translate: function (x, y, z) {
		for (var i = this.vertex.length - 1; i >= 0; i--) {
			this.vertex[i].x += x;
			this.vertex[i].y += y;
			this.vertex[i].z += z;
		};
	},
	spine: function(axis, theta) {
		var center2d = new point(),
			projection = new point(),
			coordName1 = '',
			coordName2 = '';
		switch (axis) {
			case axis = 'x':
				coordName1 = 'y';
				coordName2 = 'z';
				break;
			case axis = 'y':
				coordName1 = 'z';
				coordName2 = 'x';
				break;
			case axis = 'z':
				coordName1 = 'x';
				coordName2 = 'y';
				break;

		}
		center2d = this.center.projectionOn(coordName1, coordName2);
		for (var i = this.vertex.length - 1; i >= 0; i--) {
			this.vertex[i].rotateAroundAxis(axis, center2d, theta);
		};
	},
	projectionOn: function (axis1, axis2) {
		var maxZ = 0;
		var maxZi;
		for (var i = this.vertex.length - 1; i >= 0; i--) {
			this.vertex2d[i] = this.vertex[i].projectionOn(axis1, axis2);
			if (maxZ < this.vertex[i].z) {
				maxZ = this.vertex[i].z;
				maxZi = i;
			}
		};
		if (!this.transparent) {delete this.vertex2d[maxZi];};
	},
	draw: function() {
		this.projectionOn('x', 'y');
		drawLine(this.vertex2d[0], this.vertex2d[1]);
		drawLine(this.vertex2d[0], this.vertex2d[2]);
		drawLine(this.vertex2d[0], this.vertex2d[3]);

		drawLine(this.vertex2d[1], this.vertex2d[4]);
		drawLine(this.vertex2d[1], this.vertex2d[5]);

		drawLine(this.vertex2d[2], this.vertex2d[4]);
		drawLine(this.vertex2d[2], this.vertex2d[6]);

		drawLine(this.vertex2d[3], this.vertex2d[5]);
		drawLine(this.vertex2d[3], this.vertex2d[6]);

		drawLine(this.vertex2d[4], this.vertex2d[7]);

		drawLine(this.vertex2d[5], this.vertex2d[7]);

		drawLine(this.vertex2d[6], this.vertex2d[7]);

	}
}

element = document.getElementById("canvas1");
c = element.getContext("2d");
var n = 0;

// read the width and height of the canvas
width = element.width;
height = element.height;

// create a new pixel array
imageData = c.createImageData(width, height);

var thetaX = 1, thetaY = 1, drag = 0;

function reset () {
 	//imageData = c.createImageData(imageData);
 	 c.clearRect(0,0,400,400); 
}
function draw3d () {
	reset();
	var A = new point3d(150, 150, 150);
	 m = new cube(A, 150);
	 m.spine('y', thetaX);
	 m.spine('x', thetaY);
	 m.draw();

	//c.putImageData(imageData, 0, 0);
	if(!drag){
		thetaX += 0.01;
		thetaY += 0.01;
	}

	requestAnimFrame(draw3d);

}

// setInterval(draw3d, 1000/30);
requestAnimFrame(draw3d);

function getMousePos(element, evt) {
	var rect = element.getBoundingClientRect();
	return {
		x: evt.clientX - rect.left,
		y: evt.clientY - rect.top
	};
}

element.addEventListener('mousemove', function(evt) {
	if (drag) {
		mousePos2 = getMousePos(element, evt);
		thetaX += (mousePos2.x-mousePos1.x)/400*Math.PI;
		thetaY += (mousePos2.y-mousePos1.y)/400*Math.PI;
		mousePos1 = getMousePos(element, evt);
	}
}, false);

element.addEventListener('mousedown', function(evt) {
	mousePos1 = getMousePos(element, evt);
	drag=true;
}, false);
element.addEventListener('mouseup', function(evt) {
	drag=false;
}, false);
</script>